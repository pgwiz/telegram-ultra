#!/usr/bin/env bash
###############################################################################
# hermes-pgwiz — Hermes Download Nexus management script
# Ubuntu 22.04+ / systemd
#
# Usage:
#   hermes-pgwiz              Interactive menu
#   hermes-pgwiz --menu       Interactive menu (alias)
#   hermes-pgwiz install      Fresh install from git
#   hermes-pgwiz update       Pull latest + rebuild
#   hermes-pgwiz start        Start all services
#   hermes-pgwiz stop         Stop all services
#   hermes-pgwiz restart      Restart all services
#   hermes-pgwiz status       Show service status
#   hermes-pgwiz logs [svc]   Tail logs (bot|api|ui or all)
#   hermes-pgwiz build        Build Rust crates (release)
#   hermes-pgwiz setup-env    Create/edit .env interactively
#   hermes-pgwiz auto-p       Auto-detect Python + Node env vars (PYTHON_BIN, WORKER_DIR, NODE_BIN)
#   hermes-pgwiz setup-node      Install/upgrade Node.js LTS via nvm (v17+ for yt-dlp)
#   hermes-pgwiz setup-mtproto   Authenticate Telethon session (run once, needs MPROTO vars)
###############################################################################
set -euo pipefail

# ── Paths ────────────────────────────────────────────────────────────────────
HERMES_DIR="/opt/hermes"
REPO_URL="https://github.com/pgwiz/telegram-ultra.git"
SERVICES=(hermes-bot hermes-api hermes-ui)
VENV_DIR="$HERMES_DIR/.venv"
PYTHON_BIN="$VENV_DIR/bin/python"
PIP_BIN="$VENV_DIR/bin/pip"

# ── Colors ───────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
GOLD='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m' # No Color

banner() {
    echo -e "${GOLD}"
    echo "  ╔═══════════════════════════════════════════════╗"
    echo "  ║     ⚡ HERMES DOWNLOAD NEXUS ⚡              ║"
    echo "  ║         Management Console                    ║"
    echo "  ╚═══════════════════════════════════════════════╝"
    echo -e "${NC}"
}

info()    { echo -e "${CYAN}[INFO]${NC} $*"; }
success() { echo -e "${GREEN}[OK]${NC} $*"; }
warn()    { echo -e "${YELLOW}[WARN]${NC} $*"; }
error()   { echo -e "${RED}[ERROR]${NC} $*"; }

need_root() {
    if [[ $EUID -ne 0 ]]; then
        error "This operation requires root. Run with sudo."
        exit 1
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
#  INSTALL DEPENDENCIES
# ══════════════════════════════════════════════════════════════════════════════
install_system_deps() {
    info "Installing system packages..."
    apt-get update -qq
    apt-get install -y -qq \
        build-essential pkg-config libssl-dev \
        curl git \
        python3 python3-venv python3-pip \
        ffmpeg \
        sqlite3 >/dev/null 2>&1
    success "System packages installed"
}

install_rust() {
    if command -v rustc &>/dev/null; then
        info "Rust already installed: $(rustc --version)"
    else
        info "Installing Rust via rustup..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        source "$HOME/.cargo/env" 2>/dev/null || true
        success "Rust installed: $(rustc --version)"
    fi
}

setup_python_venv() {
    info "Setting up Python virtual environment..."
    if [[ ! -d "$VENV_DIR" ]]; then
        python3 -m venv "$VENV_DIR"
        success "Created venv at $VENV_DIR"
    else
        info "Venv already exists at $VENV_DIR"
    fi

    # Upgrade pip
    "$PIP_BIN" install --upgrade pip -q

    # Install requirements
    if [[ -f "$HERMES_DIR/requirements.txt" ]]; then
        "$PIP_BIN" install -r "$HERMES_DIR/requirements.txt" -q
        success "Python requirements installed"
    else
        warn "No requirements.txt found"
    fi

    # Make venv python globally accessible via symlink
    if [[ ! -L /usr/local/bin/hermes-python ]]; then
        ln -sf "$PYTHON_BIN" /usr/local/bin/hermes-python
        success "Symlinked hermes-python -> $PYTHON_BIN"
    fi
}

setup_node_deps() {
    info "Installing Node.js dependencies..."
    cd "$HERMES_DIR/ui"
    npm install --production -q 2>/dev/null
    success "Node.js dependencies installed"
    cd "$HERMES_DIR"
}

# ══════════════════════════════════════════════════════════════════════════════
#  NODE.JS LTS (via nvm) — needed for yt-dlp JS signature solver
# ══════════════════════════════════════════════════════════════════════════════
setup_node_lts() {
    local min_ver=17
    local node_ok=false

    # Check if a sufficient node is already present
    if command -v node &>/dev/null; then
        local cur_ver
        cur_ver=$(node --version 2>/dev/null | sed 's/v//' | cut -d. -f1)
        if [[ -n "$cur_ver" ]] && [[ "$cur_ver" -ge "$min_ver" ]] 2>/dev/null; then
            success "Node.js $(node --version) meets minimum v${min_ver} for yt-dlp JS runtime"
            node_ok=true
        else
            warn "Node.js v${cur_ver} is below v${min_ver} — upgrading via nvm"
        fi
    else
        warn "Node.js not found (system apt nodejs is v12 — too old for yt-dlp)"
    fi

    if [[ "$node_ok" == "true" ]]; then
        # Copy the binary to /usr/local/bin/node (not symlink — symlinks into /root/.nvm are
        # inaccessible to the hermes service because ProtectHome=true hides /root at runtime)
        local node_path
        node_path=$(command -v node)
        if [[ "$node_path" != "/usr/local/bin/node" ]]; then
            cp -f "$node_path" /usr/local/bin/node 2>/dev/null && chmod 755 /usr/local/bin/node || true
            # npm only needed at build time (as root, /root/.nvm accessible) — symlink is fine
            local npm_path
            npm_path="$(dirname "$node_path")/npm"
            if [[ -x "$npm_path" ]]; then
                ln -sf "$npm_path" /usr/local/bin/npm 2>/dev/null || true
            fi
            info "Copied node binary -> /usr/local/bin/node (real file, not symlink)"
        fi
        return 0
    fi

    info "Installing Node.js LTS via nvm..."
    export NVM_DIR="${NVM_DIR:-$HOME/.nvm}"

    if [[ ! -s "$NVM_DIR/nvm.sh" ]]; then
        curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    fi

    # shellcheck disable=SC1091
    source "$NVM_DIR/nvm.sh"

    nvm install --lts
    nvm use --lts

    # Copy to /usr/local/bin/node as a REAL FILE (not symlink) so hermes service
    # (ProtectHome=true) can execute it — symlinks into /root/.nvm are blocked at runtime
    local new_node
    new_node=$(command -v node 2>/dev/null || nvm which current 2>/dev/null || echo "")
    if [[ -n "$new_node" && -x "$new_node" ]]; then
        cp -f "$new_node" /usr/local/bin/node && chmod 755 /usr/local/bin/node
        # npm is only used at build time by root — symlink is fine for it
        local new_npm
        new_npm="$(dirname "$new_node")/npm"
        if [[ -x "$new_npm" ]]; then
            ln -sf "$new_npm" /usr/local/bin/npm
        fi
        success "Node.js $(node --version) installed → /usr/local/bin/node (real file)"
    else
        error "nvm install completed but node binary not found — set NODE_BIN manually in .env"
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
#  BUILD
# ══════════════════════════════════════════════════════════════════════════════
build_rust() {
    info "Building Rust crates (release)... this may take a while on first run."
    cd "$HERMES_DIR"
    # Source cargo env in case it was just installed
    source "$HOME/.cargo/env" 2>/dev/null || true
    cargo build --release 2>&1
    success "Rust build complete"
    ls -lh target/release/hermes-bot target/release/hermes-api 2>/dev/null
}

# ══════════════════════════════════════════════════════════════════════════════
#  SYSTEMD SERVICE MANAGEMENT
# ══════════════════════════════════════════════════════════════════════════════
install_services() {
    info "Installing systemd service files..."
    for svc in "${SERVICES[@]}"; do
        cp "$HERMES_DIR/deploy/${svc}.service" "/etc/systemd/system/${svc}.service"
    done
    systemctl daemon-reload
    success "Systemd services installed"
}

enable_services() {
    info "Enabling services for boot..."
    for svc in "${SERVICES[@]}"; do
        systemctl enable "$svc" --quiet
    done
    success "Services enabled"
}

start_services() {
    info "Starting Hermes services..."
    for svc in "${SERVICES[@]}"; do
        systemctl start "$svc"
        echo -e "  ${GREEN}●${NC} $svc started"
    done
    success "All services started"
}

stop_services() {
    info "Stopping Hermes services..."
    for svc in "${SERVICES[@]}"; do
        systemctl stop "$svc" 2>/dev/null || true
        echo -e "  ${RED}●${NC} $svc stopped"
    done
    success "All services stopped"
}

restart_services() {
    info "Restarting Hermes services..."
    for svc in "${SERVICES[@]}"; do
        systemctl restart "$svc"
        echo -e "  ${CYAN}●${NC} $svc restarted"
    done
    success "All services restarted"
}

show_status() {
    echo ""
    echo -e "${BOLD}Service Status:${NC}"
    echo "─────────────────────────────────────────"
    for svc in "${SERVICES[@]}"; do
        local state
        state=$(systemctl is-active "$svc" 2>/dev/null || echo "inactive")
        local enabled
        enabled=$(systemctl is-enabled "$svc" 2>/dev/null || echo "disabled")
        local color
        case "$state" in
            active)   color="$GREEN" ;;
            failed)   color="$RED" ;;
            *)        color="$YELLOW" ;;
        esac
        printf "  ${color}●${NC} %-18s %s (${enabled})\n" "$svc" "$state"
    done
    echo ""
}

show_logs() {
    local svc="${1:-all}"
    if [[ "$svc" == "all" ]]; then
        journalctl -u hermes-bot -u hermes-api -u hermes-ui -f --no-hostname -n 50
    else
        journalctl -u "hermes-${svc}" -f --no-hostname -n 50
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
#  USER / ENV SETUP
# ══════════════════════════════════════════════════════════════════════════════
create_hermes_user() {
    if id hermes &>/dev/null; then
        info "User 'hermes' already exists"
    else
        info "Creating system user 'hermes'..."
        useradd -r -m -d /opt/hermes -s /bin/bash hermes
        success "User 'hermes' created"
    fi

    # Ensure hermes can read journald logs (for admin log viewer)
    if getent group systemd-journal &>/dev/null; then
        usermod -aG systemd-journal hermes 2>/dev/null || true
    fi
}

setup_env() {
    local envfile="$HERMES_DIR/.env"

    # Ensure we can read from the terminal even when called from a pipe
    if [[ ! -t 0 ]] && [[ -e /dev/tty ]]; then
        # Re-run this function with stdin from /dev/tty
        setup_env < /dev/tty
        return $?
    elif [[ ! -t 0 ]]; then
        error "Cannot run setup-env in non-interactive mode."
        error "Please run: sudo hermes-pgwiz setup-env"
        return 1
    fi

    if [[ -f "$envfile" ]]; then
        warn ".env already exists. Edit it? (y/N)"
        read -r edit
        if [[ "$edit" != "y" && "$edit" != "Y" ]]; then
            return
        fi
    fi

    echo ""
    echo -e "${BOLD}Configure Hermes environment:${NC}"
    echo ""

    read -rp "Telegram Bot Token: " bot_token
    read -rp "Admin Chat ID: " admin_chat_id
    read -rp "Download directory [/opt/hermes/downloads]: " dl_dir
    dl_dir="${dl_dir:-/opt/hermes/downloads}"
    read -rp "API port [8081]: " api_port
    api_port="${api_port:-8081}"
    read -rp "UI port [3000]: " ui_port
    ui_port="${ui_port:-3000}"
    read -rp "Session TTL seconds [3600]: " session_ttl
    session_ttl="${session_ttl:-3600}"

    # Generate JWT secret
    jwt_secret=$(openssl rand -base64 32 2>/dev/null || head -c 32 /dev/urandom | base64)

    cat > "$envfile" <<ENVEOF
TELEGRAM_BOT_TOKEN=${bot_token}
TELOXIDE_TOKEN=${bot_token}
ADMIN_CHAT_ID=${admin_chat_id}
DATABASE_PATH=./hermes.db
DOWNLOAD_DIR=${dl_dir}
JWT_SECRET=${jwt_secret}
API_HOST=0.0.0.0
API_PORT=${api_port}
NODE_UI_PORT=${ui_port}
SESSION_TTL_SECS=${session_ttl}
WORKER_DIR=.
PYTHON_BIN=${PYTHON_BIN}
# Path to node binary for yt-dlp JS challenges (v17+ required). Auto-set by auto-p.
NODE_BIN=
ENVEOF

    chown hermes:hermes "$envfile" 2>/dev/null || true
    chmod 600 "$envfile"
    success ".env configured at $envfile"

    # Create download directory
    mkdir -p "$dl_dir"
    chown hermes:hermes "$dl_dir" 2>/dev/null || true
}

# ══════════════════════════════════════════════════════════════════════════════
#  INSTALL (FRESH)
# ══════════════════════════════════════════════════════════════════════════════
do_install() {
    need_root
    banner

    echo -e "${BOLD}Starting fresh Hermes installation...${NC}"
    echo ""

    # 1. System deps
    install_system_deps

    # 2. Node.js LTS (yt-dlp JS runtime needs v17+)
    setup_node_lts

    # 3. Rust
    install_rust

    # 4. Create user
    create_hermes_user

    # 5. Clone repo
    if [[ -d "$HERMES_DIR/.git" ]]; then
        info "Repo already cloned at $HERMES_DIR"
        cd "$HERMES_DIR"
        git checkout -- . 2>/dev/null || true
        git clean -fd 2>/dev/null || true
        git pull --ff-only
    else
        if [[ -d "$HERMES_DIR" ]]; then
            warn "$HERMES_DIR exists but is not a git repo. Backing up..."
            mv "$HERMES_DIR" "${HERMES_DIR}.bak.$(date +%s)"
        fi
        info "Cloning repository..."
        git clone "$REPO_URL" "$HERMES_DIR"
        success "Repository cloned to $HERMES_DIR"
    fi

    cd "$HERMES_DIR"
    chown -R hermes:hermes "$HERMES_DIR"

    # 5. Python venv
    setup_python_venv

    # 6. Node deps
    setup_node_deps

    # 7. Install the hermes-pgwiz alias early so it's available for setup-env
    install_alias

    # 8. Build Rust
    build_rust

    # 9. Install + enable services
    install_services
    enable_services

    # 10. Create dirs
    mkdir -p "$HERMES_DIR/downloads" "$HERMES_DIR/temp"
    chown -R hermes:hermes "$HERMES_DIR"

    # 11. Configure .env (skip if stdin is not a terminal, e.g. curl | bash)
    if [[ -t 0 ]]; then
        setup_env
    else
        echo ""
        warn "Non-interactive mode detected (curl | bash)."
        warn "Skipping .env setup. Run this after install:"
        echo ""
        echo -e "  ${CYAN}sudo hermes-pgwiz setup-env${NC}"
        echo ""
    fi

    # 12. Auto-detect Python paths in .env
    if [[ -f "$HERMES_DIR/.env" ]]; then
        auto_python_env
    fi

    echo ""
    success "Installation complete!"
    echo ""
    echo -e "  Setup .env:      ${CYAN}sudo hermes-pgwiz setup-env${NC}"
    echo -e "  MTProto setup:   ${CYAN}hermes-pgwiz setup-mtproto${NC}  (if MPROTO=true)"
    echo -e "  Start services:  ${CYAN}hermes-pgwiz start${NC}"
    echo -e "  Check status:    ${CYAN}hermes-pgwiz status${NC}"
    echo -e "  View logs:       ${CYAN}hermes-pgwiz logs${NC}"
    echo ""
}

# ══════════════════════════════════════════════════════════════════════════════
#  UPDATE (PULL + REBUILD)
# ══════════════════════════════════════════════════════════════════════════════
do_update() {
    need_root
    banner

    echo -e "${BOLD}Updating Hermes...${NC}"
    echo ""

    cd "$HERMES_DIR"

    # 1. Protect local files that must not be overwritten
    local env_backup=""
    if [[ -f "$HERMES_DIR/.env" ]]; then
        env_backup=$(mktemp)
        cp "$HERMES_DIR/.env" "$env_backup"
        info ".env backed up"
    fi

    # 2. Pull latest
    info "Pulling latest changes..."
    git stash -q 2>/dev/null || true
    git pull --ff-only
    git stash pop -q 2>/dev/null || true
    success "Code updated"

    # 3. Restore .env if git somehow removed it
    if [[ -n "$env_backup" ]]; then
        if [[ ! -f "$HERMES_DIR/.env" ]]; then
            cp "$env_backup" "$HERMES_DIR/.env"
            warn ".env was removed by git — restored from backup"
        fi
        rm -f "$env_backup"
    fi

    # 4. Warn if .env is missing
    if [[ ! -f "$HERMES_DIR/.env" ]]; then
        error "No .env file found! Run: hermes-pgwiz setup-env"
    fi

    # 5. Check/install system deps
    info "Checking system dependencies..."
    install_system_deps

    # 5b. Check/upgrade Node.js (must be v17+ for yt-dlp JS runtime)
    setup_node_lts

    # 6. Update Python venv + deps
    setup_python_venv

    # 6b. Auto-detect and update Python env vars
    auto_python_env

    # 7. Update Node deps
    setup_node_deps

    # 8. Rebuild Rust
    build_rust

    # 9. Reinstall service files (may have changed)
    install_services

    # 9b. Ensure hermes user has journal access (for log viewer)
    if getent group systemd-journal &>/dev/null; then
        usermod -aG systemd-journal hermes 2>/dev/null || true
    fi

    # 10. Restart services
    restart_services

    echo ""
    success "Update complete! Services restarted."
    info ".env was preserved — not modified by update."
    show_status
}

# ══════════════════════════════════════════════════════════════════════════════
#  AUTO-DETECT PYTHON ENVIRONMENT
# ══════════════════════════════════════════════════════════════════════════════
auto_python_env() {
    local envfile="$HERMES_DIR/.env"

    if [[ ! -f "$envfile" ]]; then
        error "No .env file found. Run: hermes-pgwiz setup-env"
        return 1
    fi

    info "Auto-detecting Python environment..."

    # 1. Detect best Python binary
    local py_bin=""
    if [[ -x "$VENV_DIR/bin/python" ]]; then
        py_bin="$VENV_DIR/bin/python"
    elif [[ -x "$VENV_DIR/bin/python3" ]]; then
        py_bin="$VENV_DIR/bin/python3"
    elif command -v python3 &>/dev/null; then
        py_bin="$(command -v python3)"
    elif command -v python &>/dev/null; then
        py_bin="$(command -v python)"
    fi

    if [[ -z "$py_bin" ]]; then
        error "No Python installation found!"
        return 1
    fi

    # 2. Detect worker dir (must contain worker/ package)
    local w_dir="$HERMES_DIR"
    if [[ ! -d "$w_dir/worker" ]]; then
        warn "worker/ package not found in $w_dir"
        w_dir="."
    fi

    # 3. Update .env — set or replace each key
    set_env_var() {
        local key="$1" val="$2" file="$3"
        if grep -q "^${key}=" "$file" 2>/dev/null; then
            sed -i "s|^${key}=.*|${key}=${val}|" "$file"
        else
            echo "${key}=${val}" >> "$file"
        fi
    }

    set_env_var "PYTHON_BIN"  "$py_bin" "$envfile"
    set_env_var "WORKER_DIR"  "$w_dir"  "$envfile"

    # Verify python actually works
    local py_ver
    py_ver=$("$py_bin" --version 2>&1) || py_ver="unknown"

    # 4. Detect Node.js binary for yt-dlp JS runtime (needs v17+)
    local node_bin=""
    # Prefer /usr/local/bin/node (symlinked by setup_node_lts, accessible with ProtectHome=true)
    if [[ -x /usr/local/bin/node ]]; then
        local cur_ver
        cur_ver=$(/usr/local/bin/node --version 2>/dev/null | sed 's/v//' | cut -d. -f1)
        if [[ -n "$cur_ver" ]] && [[ "$cur_ver" -ge 17 ]] 2>/dev/null; then
            node_bin="/usr/local/bin/node"
        fi
    fi
    # Fallback: any node in PATH with version >= 17
    if [[ -z "$node_bin" ]] && command -v node &>/dev/null; then
        local cur_ver
        cur_ver=$(node --version 2>/dev/null | sed 's/v//' | cut -d. -f1)
        if [[ -n "$cur_ver" ]] && [[ "$cur_ver" -ge 17 ]] 2>/dev/null; then
            node_bin=$(command -v node)
        else
            warn "Node.js v${cur_ver} found but < v17 (too old). Run: hermes-pgwiz setup-node"
        fi
    fi
    if [[ -z "$node_bin" ]]; then
        warn "No suitable Node.js (v17+) found. JS challenges may fail. Run: hermes-pgwiz setup-node"
    fi
    if [[ -n "$node_bin" ]]; then
        set_env_var "NODE_BIN" "$node_bin" "$envfile"
    fi

    local node_ver_str
    if [[ -n "$node_bin" ]]; then
        node_ver_str=$("$node_bin" --version 2>&1) || node_ver_str="unknown"
    else
        node_ver_str="not found"
    fi

    echo ""
    success "Python environment configured:"
    echo -e "  PYTHON_BIN  = ${CYAN}${py_bin}${NC}  (${py_ver})"
    echo -e "  WORKER_DIR  = ${CYAN}${w_dir}${NC}"
    echo -e "  NODE_BIN    = ${CYAN}${node_bin:-<not set>}${NC}  (${node_ver_str})"
    echo ""
}

# ══════════════════════════════════════════════════════════════════════════════
#  MTPROTO SESSION SETUP
# ══════════════════════════════════════════════════════════════════════════════
setup_mtproto() {
    local envfile="$HERMES_DIR/.env"

    # Need an interactive terminal for OTP prompt
    if [[ ! -t 0 ]] && [[ -e /dev/tty ]]; then
        setup_mtproto < /dev/tty
        return $?
    elif [[ ! -t 0 ]]; then
        error "setup-mtproto requires an interactive terminal."
        return 1
    fi

    # Source .env to read MPROTO vars
    if [[ -f "$envfile" ]]; then
        # shellcheck source=/dev/null
        set -a; source "$envfile"; set +a
    fi

    local missing=()
    [[ -z "${TELEGRAM_API_ID:-}"    ]] && missing+=("TELEGRAM_API_ID")
    [[ -z "${TELEGRAM_API_HASH:-}"  ]] && missing+=("TELEGRAM_API_HASH")
    [[ -z "${TELEGRAM_PHONE:-}"     ]] && missing+=("TELEGRAM_PHONE")
    [[ -z "${STORAGE_CHANNEL_ID:-}" ]] && missing+=("STORAGE_CHANNEL_ID")

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required env vars in .env: ${missing[*]}"
        error "Set them first with: hermes-pgwiz setup-env"
        return 1
    fi

    info "Running MTProto session setup (you will receive a Telegram OTP)..."
    cd "$HERMES_DIR"
    "$PYTHON_BIN" worker/setup_session.py
}

# ══════════════════════════════════════════════════════════════════════════════
#  ALIAS INSTALLATION
# ══════════════════════════════════════════════════════════════════════════════
install_alias() {
    local script_path="$HERMES_DIR/deploy/hermes-pgwiz"
    local link_path="/usr/local/bin/hermes-pgwiz"

    # Ensure the deploy script is executable
    chmod +x "$script_path"

    # Create symlink
    ln -sf "$script_path" "$link_path"
    success "Alias installed: hermes-pgwiz -> $script_path"
}

# ══════════════════════════════════════════════════════════════════════════════
#  INTERACTIVE MENU
# ══════════════════════════════════════════════════════════════════════════════
interactive_menu() {
    while true; do
        clear
        banner
        show_status 2>/dev/null || true

        echo -e "${BOLD}Choose an action:${NC}"
        echo ""
        echo -e "  ${CYAN}1${NC})  Start all services"
        echo -e "  ${CYAN}2${NC})  Stop all services"
        echo -e "  ${CYAN}3${NC})  Restart all services"
        echo -e "  ${CYAN}4${NC})  View status"
        echo -e "  ${CYAN}5${NC})  View logs (follow)"
        echo -e "  ${CYAN}6${NC})  Update (git pull + rebuild)"
        echo -e "  ${CYAN}7${NC})  Rebuild only (cargo build)"
        echo -e "  ${CYAN}8${NC})  Edit .env"
        echo -e "  ${CYAN}9${NC})  Full install"
        echo -e "  ${CYAN}0${NC})  Exit"
        echo ""
        read -rp "  Select [0-9]: " choice

        case "$choice" in
            1) need_root; start_services; read -rp "Press Enter..." ;;
            2) need_root; stop_services; read -rp "Press Enter..." ;;
            3) need_root; restart_services; read -rp "Press Enter..." ;;
            4) show_status; read -rp "Press Enter..." ;;
            5)
                echo -e "  ${CYAN}a${NC}) All  ${CYAN}b${NC}) Bot  ${CYAN}p${NC}) API  ${CYAN}u${NC}) UI"
                read -rp "  Which? [a]: " logchoice
                case "${logchoice:-a}" in
                    b) show_logs bot ;;
                    p) show_logs api ;;
                    u) show_logs ui ;;
                    *) show_logs all ;;
                esac
                ;;
            6) do_update ;;
            7) build_rust; read -rp "Press Enter..." ;;
            8) setup_env; read -rp "Press Enter..." ;;
            9) do_install ;;
            0) echo "Goodbye."; exit 0 ;;
            *) warn "Invalid choice"; sleep 1 ;;
        esac
    done
}

# ══════════════════════════════════════════════════════════════════════════════
#  MAIN DISPATCH
# ══════════════════════════════════════════════════════════════════════════════
main() {
    local cmd="${1:-menu}"

    case "$cmd" in
        install)       do_install ;;
        update)        do_update ;;
        start)         need_root; start_services ;;
        stop)          need_root; stop_services ;;
        restart)       need_root; restart_services ;;
        status)        show_status ;;
        logs)          show_logs "${2:-all}" ;;
        build)         build_rust ;;
        setup-env)     need_root; setup_env ;;
        auto-p)        need_root; auto_python_env ;;
        setup-node)    need_root; setup_node_lts ;;
        setup-mtproto) setup_mtproto ;;
        --menu|menu)   interactive_menu ;;
        --help|-h|help)
            echo "Usage: hermes-pgwiz [command]"
            echo ""
            echo "Commands:"
            echo "  install      Fresh install from git"
            echo "  update       Pull latest + rebuild + restart"
            echo "  start        Start all services"
            echo "  stop         Stop all services"
            echo "  restart      Restart all services"
            echo "  status       Show service status"
            echo "  logs [svc]   Tail logs (bot|api|ui|all)"
            echo "  build        Build Rust crates (release)"
            echo "  setup-env    Configure .env"
            echo "  auto-p       Auto-detect Python + Node env vars (PYTHON_BIN, WORKER_DIR, NODE_BIN)"
            echo "  setup-node   Install/upgrade Node.js LTS via nvm (required for yt-dlp, v17+)"
            echo "  setup-mtproto  Authenticate Telethon session for MTProto uploads (run once)"
            echo "  --menu       Interactive menu (default)"
            echo ""
            ;;
        *)
            error "Unknown command: $cmd"
            echo "Run: hermes-pgwiz --help"
            exit 1
            ;;
    esac
}

main "$@"
